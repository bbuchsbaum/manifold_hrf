% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/core_alternating_optimization.R,
%   R/core_voxelfit_engine.R
\name{estimate_final_condition_betas_core}
\alias{estimate_final_condition_betas_core}
\title{Estimate Final Condition Betas (Core)}
\usage{
estimate_final_condition_betas_core(
  Y_proj_matrix,
  X_condition_list_proj_matrices,
  H_shapes_allvox_matrix,
  lambda_beta_final = 0,
  control_alt_list = list(max_iter = 1)
)

estimate_final_condition_betas_core(
  Y_proj_matrix,
  X_condition_list_proj_matrices,
  H_shapes_allvox_matrix,
  lambda_beta_final = 0,
  control_alt_list = list(max_iter = 1)
)
}
\arguments{
\item{Y_proj_matrix}{n x V projected BOLD matrix}

\item{X_condition_list_proj_matrices}{list of k n x p design matrices}

\item{H_shapes_allvox_matrix}{p x V HRF shapes for all voxels}

\item{lambda_beta_final}{numeric scalar ridge penalty (default 0)}

\item{control_alt_list}{list with control parameters (default \code{list(max_iter = 1)}).
Recognized elements are \code{max_iter} (positive integer) and
\code{rel_change_tol} (non-negative numeric).}
}
\value{
Beta_condition_final_matrix A k x V matrix of final condition-level
beta estimates

k x V matrix of final condition-level betas
}
\description{
Re-estimates condition-level beta coefficients using the spatially smoothed
HRF shapes from the manifold estimation pipeline.
}
\details{
This function implements Component 4 of the M-HRF-LSS pipeline.
It re-estimates condition-level amplitudes using the final smoothed HRF
shapes. For each voxel, it constructs condition-specific regressors by
convolving the design matrices with the voxel's HRF, then solves a
ridge regression problem. The MVP version does a single pass (max_iter=1),
but the framework supports iterative refinement between HRFs and betas.
}
\examples{
\dontrun{
# Setup
n <- 200  # timepoints
p <- 30   # HRF length
k <- 3    # conditions
V <- 100  # voxels

# Projected data
Y_proj <- matrix(rnorm(n * V), n, V)

# Condition design matrices
X_cond_list <- lapply(1:k, function(c) {
  # Simple block design for each condition
  X <- matrix(0, n, p)
  # Add some events
  onsets <- seq(10 + (c-1)*20, n-p, by = 60)
  for (onset in onsets) {
    X[onset:(onset+p-1), ] <- diag(p)
  }
  X
})

# HRF shapes (from previous components)
H_shapes <- matrix(rnorm(p * V), p, V)

# Estimate final betas
Beta_final <- estimate_final_condition_betas_core(
  Y_proj, X_cond_list, H_shapes,
  lambda_beta_final = 0.01,
  control_alt_list = list(max_iter = 1)
)
}

}
