% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/core_alternating_optimization.R
\name{estimate_final_condition_betas_core}
\alias{estimate_final_condition_betas_core}
\title{Estimate Final Condition Betas (Core)}
\usage{
estimate_final_condition_betas_core(
  Y_proj_matrix,
  X_condition_list_proj_matrices,
  H_shapes_allvox_matrix,
  lambda_beta_final = 0.01,
  control_alt_list = list(max_iter = 1, rel_change_tol = 1e-04)
)
}
\arguments{
\item{Y_proj_matrix}{The n x V confound-projected data matrix, where n is
timepoints and V is number of voxels}

\item{X_condition_list_proj_matrices}{List of k projected design matrices
(each n x p), where k is number of conditions and p is HRF length}

\item{H_shapes_allvox_matrix}{The p x V matrix of smoothed voxel-specific
HRF shapes from Component 3}

\item{lambda_beta_final}{Ridge penalty parameter for final beta estimation
(scalar, typically small like 0.01)}

\item{control_alt_list}{List with control parameters:
\itemize{
\item \code{max_iter}: Maximum number of iterations (default 1 for MVP)
\item \code{rel_change_tol}: Relative change tolerance for convergence
(default 1e-4)
}}
}
\value{
Beta_condition_final_matrix A k x V matrix of final condition-level
beta estimates
}
\description{
Re-estimates condition-level beta coefficients using the spatially smoothed
HRF shapes from the manifold estimation pipeline.
}
\details{
This function implements Component 4 of the M-HRF-LSS pipeline.
It re-estimates condition-level amplitudes using the final smoothed HRF
shapes. For each voxel, it constructs condition-specific regressors by
convolving the design matrices with the voxel's HRF, then solves a
ridge regression problem. The MVP version does a single pass (max_iter=1),
but the framework supports iterative refinement between HRFs and betas.
}
\examples{
\dontrun{
# Setup
n <- 200  # timepoints
p <- 30   # HRF length
k <- 3    # conditions
V <- 100  # voxels

# Projected data
Y_proj <- matrix(rnorm(n * V), n, V)

# Condition design matrices
X_cond_list <- lapply(1:k, function(c) {
  # Simple block design for each condition
  X <- matrix(0, n, p)
  # Add some events
  onsets <- seq(10 + (c-1)*20, n-p, by = 60)
  for (onset in onsets) {
    X[onset:(onset+p-1), ] <- diag(p)
  }
  X
})

# HRF shapes (from previous components)
H_shapes <- matrix(rnorm(p * V), p, V)

# Estimate final betas
Beta_final <- estimate_final_condition_betas_core(
  Y_proj, X_cond_list, H_shapes,
  lambda_beta_final = 0.01,
  control_alt_list = list(max_iter = 1)
)
}

}
